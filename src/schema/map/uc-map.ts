import { COMPILER_MODULE } from '../../impl/module-names.js';
import { jsPropertyKey } from '../../impl/quote-property-key.js';
import { UcInstructions } from '../uc-instructions.js';
import { ucSchemaName } from '../uc-schema-name.js';
import { UcSchema, ucSchema } from '../uc-schema.js';

/**
 * URI charge map represented as JavaScript object.
 */
export interface UcMap {
  [key: string]: unknown;
}

export namespace UcMap {
  /**
   * URI charge schema definition for JavaScript {@link UcMap object} serialized as map.
   *
   * Such schema can be built with {@link ucMap} function.
   *
   * @typeParam TEntriesSpec - Per-entry schema specifier type.
   * @typeParam TExtraSpec - Schema specifier for extra entries, or `false` to prohibit extra entries.
   */
  export interface Schema<
    TEntriesSpec extends Schema.Entries.Spec = Schema.Entries.Spec,
    TExtraSpec extends UcSchema.Spec | false = false,
  > extends UcSchema<ObjectType<TEntriesSpec, TExtraSpec>> {
    readonly type: 'map';
    readonly entries: Schema.Entries<TEntriesSpec>;
    readonly extra: TExtraSpec extends UcSchema.Spec ? UcSchema.Of<TExtraSpec> : false;
  }

  /**
   * Type of object compatible with schema of URI charge map.
   *
   * @typeParam TEntriesSpec - Per-entry schema specifier type.
   * @typeParam TExtraSpec - Schema specifier for extra entries, or `false` to prohibit extra entries.
   */
  export type ObjectType<
    TEntriesSpec extends Schema.Entries.Spec,
    TExtraSpec extends UcSchema.Spec | false = false,
  > = {
    -readonly [key in RequiredKeys<TEntriesSpec>]: UcSchema.DataType<TEntriesSpec[key]>;
  } & {
    -readonly [key in OptionalKeys<TEntriesSpec>]?: UcSchema.DataType<TEntriesSpec[key]>;
  } & (TExtraSpec extends UcSchema.Spec<any>
      ? { [key in Exclude<string, keyof TEntriesSpec>]: UcSchema.DataType<TExtraSpec> }
      : { [key in never]: never });

  export type Required<
    TEntriesSpec extends Schema.Entries.Spec,
    TKey extends keyof TEntriesSpec = keyof TEntriesSpec,
  > = undefined extends UcSchema.DataType<TEntriesSpec[TKey]> ? TKey : never;

  export type RequiredKeys<
    TEntriesSpec extends Schema.Entries.Spec,
    TKey extends keyof TEntriesSpec = keyof TEntriesSpec,
  > = undefined extends UcSchema.DataType<TEntriesSpec[TKey]> ? never : TKey;

  export type OptionalKeys<
    TEntriesSpec extends Schema.Entries.Spec,
    TKey extends keyof TEntriesSpec = keyof TEntriesSpec,
  > = undefined extends UcSchema.DataType<TEntriesSpec[TKey]> ? TKey : never;

  export type ExtraKeys<TEntriesSpec extends Schema.Entries.Spec> = Exclude<
    string,
    keyof TEntriesSpec
  >;

  export namespace Schema {
    /**
     * Per-entry schema of URI charge map.
     *
     * @typeParam TEntriesSpec - Per-entry schema specifier type.
     * @typeParam TExtraSpec - Schema specifier for extra entries, or `false` to prohibit extra entries.
     */
    export type Entries<TEntriesSpec extends Entries.Spec> = {
      readonly [key in keyof TEntriesSpec]: UcSchema.Of<TEntriesSpec[key]>;
    };

    export namespace Entries {
      /**
       * Per-entry schema specifier of the map.
       *
       * Each property corresponds to a map entry with data type implied by corresponding schema specifier.
       */
      export type Spec = {
        readonly [key in string]: UcSchema.Spec;
      };
    }

    /**
     * Additional options for URI charge map schema.
     *
     * @typeParam TEntriesSpec - Per-entry schema specifier type.
     * @typeParam TExtraSpec - Schema specifier for extra entries, or `false` to prohibit extra entries.
     */
    export interface BaseOptions {
      /**
       * Unique schema identifier.
       *
       * @defaultValue Autogenerated string.
       */
      readonly id?: string | UcSchema.Class | undefined;
    }

    export type Options<TExtraSpec extends UcSchema.Spec> = ExactOptions | ExtraOptions<TExtraSpec>;

    export interface ExactOptions extends BaseOptions {
      readonly extra?: false | undefined;
    }

    export interface ExtraOptions<TExtraSpec extends UcSchema.Spec> extends BaseOptions {
      readonly extra: TExtraSpec;
    }
  }
}

/**
 * Creates a reference to URI charge schema for JavaScript {@link UcMap object} serialized as map.
 *
 * @typeParam TEntriesSpec - Per-entry schema specifier type.
 * @param entries - Per-entry schema entries spec.
 * @param options - Schema options.
 *
 * @returns Reference to schema of URI charge map.
 */
export function ucMap<TEntriesSpec extends UcMap.Schema.Entries.Spec>(
  spec: TEntriesSpec,
  options?: UcMap.Schema.ExactOptions,
): UcMap.Schema<TEntriesSpec>;

export function ucMap<
  TEntriesSpec extends UcMap.Schema.Entries.Spec,
  TExtraSpec extends UcSchema.Spec,
>(
  spec: TEntriesSpec,
  options: UcMap.Schema.ExtraOptions<TExtraSpec>,
): UcMap.Schema<TEntriesSpec, TExtraSpec>;

export function ucMap<
  TEntriesSpec extends UcMap.Schema.Entries.Spec,
  TExtraSpec extends UcSchema.Spec,
>(
  spec: TEntriesSpec,
  { id, extra }: UcMap.Schema.Options<TExtraSpec> = {},
): UcMap.Schema<TEntriesSpec, TExtraSpec> {
  const entries: [string, UcSchema][] = Object.entries<UcSchema.Spec>(spec).map(([key, spec]) => [key, ucSchema(spec)]);

  return {
    type: 'map',
    id: id ?? `map_${++UcMap$idSeq}`,
    with: UcMap$instructions,
    entries: Object.fromEntries(entries) as UcMap.Schema.Entries<TEntriesSpec>,
    extra: (extra ? ucSchema(extra) : false) as UcMap.Schema<TEntriesSpec, TExtraSpec>['extra'],
    toString() {
      let out = '{';

      entries.every(([key, entry], i) => {
        if (i) {
          out += ', ';
        }
        out += jsPropertyKey(key) + ': ' + ucSchemaName(entry);

        if (i < 2) {
          return true;
        }

        out += ', ...';

        return false;
      });

      return out + '}';
    },
  };
}

let UcMap$idSeq = 0;

const UcMap$instructions: UcInstructions = {
  deserializer: {
    use: {
      from: COMPILER_MODULE,
      feature: 'MapUcrxTemplate',
    },
  },
  serializer: {
    use: {
      from: COMPILER_MODULE,
      feature: 'ucsSupportMap',
    },
  },
};
